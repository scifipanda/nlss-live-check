{"ast":null,"code":"var fs = require('fs');\n\nvar sys = require('util');\n\nexports.defaultBoundary = '48940923NODERESLTER3890457293'; // This little object allows us hijack the write method via duck-typing\n// and write to strings or regular streams that support the write method.\n\nfunction Stream(stream) {\n  //If the user pases a string for stream,we initalize one to write to\n  if (this._isString(stream)) {\n    this.string = \"\";\n  }\n\n  this.stream = stream;\n}\n\nStream.prototype = {\n  //write to an internal String or to the Stream\n  write: function (data) {\n    if (this.string != undefined) {\n      this.string += data;\n    } else {\n      this.stream.write(data, \"binary\");\n    }\n  },\n  //stolen from underscore.js\n  _isString: function (obj) {\n    return !!(obj === '' || obj && obj.charCodeAt && obj.substr);\n  }\n};\n\nfunction File(path, filename, fileSize, encoding, contentType) {\n  this.path = path;\n  this.filename = filename || this._basename(path);\n  this.fileSize = fileSize;\n  this.encoding = encoding || \"binary\";\n  this.contentType = contentType || 'application/octet-stream';\n}\n\nFile.prototype = {\n  _basename: function (path) {\n    var parts = path.split(/\\/|\\\\/);\n    return parts[parts.length - 1];\n  }\n};\n\nfunction Data(filename, contentType, data) {\n  this.filename = filename;\n  this.contentType = contentType || 'application/octet-stream';\n  this.data = data;\n}\n\nfunction Part(name, value, boundary) {\n  this.name = name;\n  this.value = value;\n  this.boundary = boundary;\n}\n\nPart.prototype = {\n  //returns the Content-Disposition header\t\t\n  header: function () {\n    var header;\n\n    if (this.value.data) {\n      header = \"Content-Disposition: form-data; name=\\\"\" + this.name + \"\\\"; filename=\\\"\" + this.value.filename + \"\\\"\\r\\n\" + \"Content-Length: \" + this.value.data.length + \"\\r\\n\" + \"Content-Type: \" + this.value.contentType;\n    } else if (this.value instanceof File) {\n      header = \"Content-Disposition: form-data; name=\\\"\" + this.name + \"\\\"; filename=\\\"\" + this.value.filename + \"\\\"\\r\\n\" + \"Content-Length: \" + this.value.fileSize + \"\\r\\n\" + \"Content-Type: \" + this.value.contentType;\n    } else {\n      header = \"Content-Disposition: form-data; name=\\\"\" + this.name + \"\\\"\";\n    }\n\n    return \"--\" + this.boundary + \"\\r\\n\" + header + \"\\r\\n\\r\\n\";\n  },\n  //calculates the size of the Part\n  sizeOf: function () {\n    var valueSize;\n\n    if (this.value instanceof File) {\n      valueSize = this.value.fileSize;\n    } else if (this.value.data) {\n      valueSize = this.value.data.length;\n    } else if (typeof this.value === 'number') {\n      valueSize = this.value.toString().length;\n    } else {\n      valueSize = this.value.length;\n    }\n\n    return valueSize + this.header().length + 2;\n  },\n  // Writes the Part out to a writable stream that supports the write(data) method\n  // You can also pass in a String and a String will be returned to the callback\n  // with the whole Part\n  // Calls the callback when complete\n  write: function (stream, callback) {\n    var self = this; //first write the Content-Disposition\n\n    stream.write(this.header()); //Now write out the body of the Part\n\n    if (this.value instanceof File) {\n      fs.open(this.value.path, \"r\", 0666, function (err, fd) {\n        if (err) throw err;\n        var position = 0;\n\n        (function reader() {\n          fs.read(fd, 1024 * 4, position, \"binary\", function (er, chunk) {\n            if (er) callback(err);\n            stream.write(chunk);\n            position += 1024 * 4;\n            if (chunk) reader();else {\n              stream.write(\"\\r\\n\");\n              callback();\n              fs.close(fd);\n            }\n          });\n        })(); // reader() \n\n      });\n    } else if (this.value instanceof Data) {\n      stream.write(this.value.data);\n      stream.write(\"\\r\\n\");\n      callback();\n    } else {\n      stream.write(this.value + \"\\r\\n\");\n      callback();\n    }\n  }\n}; //Renamed to MultiPartRequest from Request\n\nfunction MultiPartRequest(data, boundary) {\n  this.encoding = 'binary';\n  this.boundary = boundary || exports.defaultBoundary;\n  this.data = data;\n  this.partNames = this._partNames();\n}\n\nMultiPartRequest.prototype = {\n  _partNames: function () {\n    var partNames = [];\n\n    for (var name in this.data) {\n      partNames.push(name);\n    }\n\n    return partNames;\n  },\n  write: function (stream, callback) {\n    var partCount = 0,\n        self = this; // wrap the stream in our own Stream object\n    // See the Stream function above for the benefits of this\n\n    var stream = new Stream(stream); // Let each part write itself out to the stream\n\n    (function writePart() {\n      var partName = self.partNames[partCount];\n      var part = new Part(partName, self.data[partName], self.boundary);\n      part.write(stream, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        partCount += 1;\n        if (partCount < self.partNames.length) writePart();else {\n          stream.write('--' + self.boundary + '--' + \"\\r\\n\");\n          if (callback) callback(stream.string || \"\");\n        }\n      });\n    })();\n  }\n};\nvar exportMethods = {\n  file: function (path, filename, fileSize, encoding, contentType) {\n    return new File(path, filename, fileSize, encoding, contentType);\n  },\n  data: function (filename, contentType, data) {\n    return new Data(filename, contentType, data);\n  },\n  sizeOf: function (parts, boundary) {\n    var totalSize = 0;\n    boundary = boundary || exports.defaultBoundary;\n\n    for (var name in parts) totalSize += new Part(name, parts[name], boundary).sizeOf();\n\n    return totalSize + boundary.length + 6;\n  },\n  write: function (stream, data, callback, boundary) {\n    var r = new MultiPartRequest(data, boundary);\n    r.write(stream, callback);\n    return r;\n  }\n};\nObject.keys(exportMethods).forEach(function (exportMethod) {\n  exports[exportMethod] = exportMethods[exportMethod];\n});","map":null,"metadata":{},"sourceType":"script"}