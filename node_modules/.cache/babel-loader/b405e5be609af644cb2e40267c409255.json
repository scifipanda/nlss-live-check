{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var DocumentPosition,\n      NodeType,\n      XMLCData,\n      XMLComment,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDummy,\n      XMLElement,\n      XMLNamedNodeMap,\n      XMLNode,\n      XMLNodeList,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLText,\n      getValue,\n      isEmpty,\n      isFunction,\n      isObject,\n      hasProp = {}.hasOwnProperty,\n      splice = [].splice;\n\n  var _require = require('./Utility');\n\n  isObject = _require.isObject;\n  isFunction = _require.isFunction;\n  isEmpty = _require.isEmpty;\n  getValue = _require.getValue;\n  XMLElement = null;\n  XMLCData = null;\n  XMLComment = null;\n  XMLDeclaration = null;\n  XMLDocType = null;\n  XMLRaw = null;\n  XMLText = null;\n  XMLProcessingInstruction = null;\n  XMLDummy = null;\n  NodeType = null;\n  XMLNodeList = null;\n  XMLNamedNodeMap = null;\n  DocumentPosition = null; // Represents a generic XMl element\n\n  module.exports = XMLNode = function () {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n\n        this.value = null;\n        this.children = [];\n        this.baseURI = null; // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      } // Sets the parent node of this node and its children recursively\n      // `parent` the parent node\n\n\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n\n        ref1 = this.children;\n        results = [];\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n\n        return results;\n      } // Creates a child element node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n\n        if (attributes === null && text == null) {\n          attributes = {};\n          text = null;\n        }\n\n        if (attributes == null) {\n          attributes = {};\n        }\n\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          var _ref = [attributes, text];\n          text = _ref[0];\n          attributes = _ref[1];\n        }\n\n        if (name != null) {\n          name = getValue(name);\n        } // expand if array\n\n\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          } // evaluate if function\n\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply()); // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            } // assign attributes\n\n\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy(); // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key); // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && val == null) {\n              lastChild = this.dummy(); // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              } // expand child nodes under parent\n\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              // text node\n              lastChild = this.element(key, val);\n            }\n          } // skip null nodes\n\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text); // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text); // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text); // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text); // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n\n        return lastChild;\n      } // Creates a child element node before the current node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed; // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i); // add the new child\n\n            children.push(newChild); // add back removed children after new child\n\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          } // temporarily remove children starting *with* this\n\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      } // Creates a child element node after the current node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        } // temporarily remove children starting *after* this\n\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      } // Deletes a child element node\n\n\n      remove() {\n        var i, ref1;\n\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      } // Creates a node\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      node(name, attributes, text) {\n        var child;\n\n        if (name != null) {\n          name = getValue(name);\n        }\n\n        attributes || (attributes = {});\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          var _ref2 = [attributes, text];\n          text = _ref2[0];\n          attributes = _ref2[1];\n        }\n\n        child = new XMLElement(this, name, attributes);\n\n        if (text != null) {\n          child.text(text);\n        }\n\n        this.children.push(child);\n        return child;\n      } // Creates a text node\n      // `value` element text\n\n\n      text(value) {\n        var child;\n\n        if (isObject(value)) {\n          this.element(value);\n        }\n\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a CDATA node\n      // `value` element text without CDATA delimiters\n\n\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a comment node\n      // `value` comment text\n\n\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a comment node before the current node\n      // `value` comment text\n\n\n      commentBefore(value) {\n        var child, i, removed; // temporarily remove children starting *with* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i); // add the new child\n\n        child = this.parent.comment(value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates a comment node after the current node\n      // `value` comment text\n\n\n      commentAfter(value) {\n        var child, i, removed; // temporarily remove children starting *after* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.comment(value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Adds unescaped raw text\n      // `value` text\n\n\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      } // Adds a dummy node\n\n\n      dummy() {\n        var child;\n        child = new XMLDummy(this); // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n        // @children.push child\n\n        return child;\n      } // Adds a processing instruction\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n\n        if (target != null) {\n          target = getValue(target);\n        }\n\n        if (value != null) {\n          value = getValue(value);\n        }\n\n        if (Array.isArray(target)) {\n          // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) {\n          // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n\n        return this;\n      } // Creates a processing instruction node before the current node\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instructionBefore(target, value) {\n        var child, i, removed; // temporarily remove children starting *with* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i); // add the new child\n\n        child = this.parent.instruction(target, value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates a processing instruction node after the current node\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instructionAfter(target, value) {\n        var child, i, removed; // temporarily remove children starting *after* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.instruction(target, value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates the xml declaration\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n\n\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone); // Replace XML declaration if exists, otherwise insert at top\n\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n\n        return doc.root() || doc;\n      } // Creates the document type declaration\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n\n\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children; // Replace DTD if exists\n\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n\n        ref2 = doc.children; // insert before root node if the root node exists\n\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        } // otherwise append to end\n\n\n        doc.children.push(doctype);\n        return doctype;\n      } // Gets the parent node\n\n\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n\n        return this.parent;\n      } // Gets the root node\n\n\n      root() {\n        var node;\n        node = this;\n\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      } // Gets the node representing the XML document\n\n\n      document() {\n        var node;\n        node = this;\n\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      } // Ends the document and converts string\n\n\n      end(options) {\n        return this.document().end(options);\n      } // Gets the previous node\n\n\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n\n        return this.parent.children[i - 1];\n      } // Gets the next node\n\n\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n\n        return this.parent.children[i + 1];\n      } // Imports cloned root from another XML document\n      // `doc` the XML document to insert nodes from\n\n\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot); // set properties if imported element becomes the root node\n\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot; // set dtd name\n\n          if (this.children) {\n            ref1 = this.children;\n\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n\n        return this;\n      } // Returns debug string for this node\n\n\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n\n        if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      } // Aliases\n\n\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      } // can be deprecated in a future release\n\n\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      } // Adds or modifies an attribute.\n      // `name` attribute name\n      // `value` attribute value\n\n\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      } // Removes an attribute\n      // `name` attribute name\n\n\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      } // DOM level 1 functions to be implemented later\n\n\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      } // DOM level 2\n\n\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      } // DOM level 3 functions to be implemented later\n\n\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n\n        for (i = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      } // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n\n\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n\n        return other === this || this.isDescendant(other);\n      } // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n\n\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n\n          if (node === child) {\n            return true;\n          }\n\n          isDescendantChild = child.isDescendant(node);\n\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n\n        return false;\n      } // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n\n\n      isAncestor(node) {\n        return node.isDescendant(this);\n      } // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n\n\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      } // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n\n\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      } // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n\n\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function (childNode) {\n          pos++;\n\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      } // Depth-first preorder traversal through the XML tree\n\n\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    }\n\n    ; // DOM level 1\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function () {\n        return this.name;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function () {\n        return this.type;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function () {\n        return this.value;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function () {\n        return this.parent;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function () {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n\n        return this.childNodeList;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function () {\n        return this.children[0] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function () {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function () {\n        return this.document() || null;\n      }\n    }); // DOM level 3\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function () {\n        var child, j, len, ref1, str;\n\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function (value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n    return XMLNode;\n  }.call(this);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}