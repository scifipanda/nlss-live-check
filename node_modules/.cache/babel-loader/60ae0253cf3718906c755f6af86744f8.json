{"ast":null,"code":"var RE_SPACEDASH = /[- ]/g; // Module exports\n\nvar iconv = module.exports = {\n  toEncoding: function (str, encoding) {\n    return iconv.getCodec(encoding).toEncoding(str);\n  },\n  fromEncoding: function (buf, encoding) {\n    return iconv.getCodec(encoding).fromEncoding(buf);\n  },\n  encodingExists: function (enc) {\n    loadEncodings();\n    enc = enc.replace(RE_SPACEDASH, \"\").toLowerCase();\n    return iconv.encodings[enc] !== undefined;\n  },\n  defaultCharUnicode: 'ï¿½',\n  defaultCharSingleByte: '?',\n  encodingsLoaded: false,\n  // Get correct codec for given encoding.\n  getCodec: function (encoding) {\n    loadEncodings();\n    var enc = encoding || \"utf8\";\n    var codecOptions = undefined;\n\n    while (1) {\n      if (getType(enc) === \"String\") enc = enc.replace(RE_SPACEDASH, \"\").toLowerCase();\n      var codec = iconv.encodings[enc];\n      var type = getType(codec);\n\n      if (type === \"String\") {\n        // Link to other encoding.\n        codecOptions = {\n          originalEncoding: enc\n        };\n        enc = codec;\n      } else if (type === \"Object\" && codec.type != undefined) {\n        // Options for other encoding.\n        codecOptions = codec;\n        enc = codec.type;\n      } else if (type === \"Function\") // Codec itself.\n        return codec(codecOptions);else throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\" + enc + \"')\");\n    }\n  },\n  // Define basic encodings\n  encodings: {\n    internal: function (options) {\n      return {\n        toEncoding: toInternalEncoding,\n        fromEncoding: fromInternalEncoding,\n        options: options\n      };\n    },\n    utf8: \"internal\",\n    ucs2: \"internal\",\n    binary: \"internal\",\n    ascii: \"internal\",\n    base64: \"internal\",\n    // Codepage single-byte encodings.\n    singlebyte: function (options) {\n      // Prepare chars if needed\n      if (!options.charsBuf) {\n        if (!options.chars || options.chars.length !== 128 && options.chars.length !== 256) throw new Error(\"Encoding '\" + options.type + \"' has incorrect 'chars' (must be of len 128 or 256)\");\n        if (options.chars.length === 128) options.chars = asciiString + options.chars;\n        options.charsBuf = new Buffer(options.chars, 'ucs2');\n      }\n\n      if (!options.revCharsBuf) {\n        options.revCharsBuf = new Buffer(65536);\n        var defChar = iconv.defaultCharSingleByte.charCodeAt(0);\n\n        for (var i = 0; i < options.revCharsBuf.length; i++) options.revCharsBuf[i] = defChar;\n\n        for (var i = 0; i < options.chars.length; i++) options.revCharsBuf[options.chars.charCodeAt(i)] = i;\n      }\n\n      return {\n        toEncoding: toSingleByteEncoding,\n        fromEncoding: fromSingleByteEncoding,\n        options: options\n      };\n    },\n    // Codepage double-byte encodings.\n    table: function (options) {\n      if (!options.table) {\n        throw new Error(\"Encoding '\" + options.type + \"' has incorect 'table' option\");\n      }\n\n      if (!options.revCharsTable) {\n        var revCharsTable = options.revCharsTable = {};\n\n        for (var i = 0; i <= 0xFFFF; i++) {\n          revCharsTable[i] = 0;\n        }\n\n        var table = options.table;\n\n        for (var key in table) {\n          revCharsTable[table[key]] = +key;\n        }\n      }\n\n      return {\n        toEncoding: toTableEncoding,\n        fromEncoding: fromTableEncoding,\n        options: options\n      };\n    }\n  }\n};\n\nfunction toInternalEncoding(str) {\n  return new Buffer(ensureString(str), this.options.originalEncoding);\n}\n\nfunction fromInternalEncoding(buf) {\n  return ensureBuffer(buf).toString(this.options.originalEncoding);\n}\n\nfunction toTableEncoding(str) {\n  str = ensureString(str);\n  var strLen = str.length;\n  var revCharsTable = this.options.revCharsTable;\n  var newBuf = new Buffer(strLen * 2),\n      gbkcode,\n      unicode,\n      defaultChar = revCharsTable[iconv.defaultCharUnicode.charCodeAt(0)];\n\n  for (var i = 0, j = 0; i < strLen; i++) {\n    unicode = str.charCodeAt(i);\n\n    if (unicode >> 7) {\n      gbkcode = revCharsTable[unicode] || defaultChar;\n      newBuf[j++] = gbkcode >> 8; //high byte;\n\n      newBuf[j++] = gbkcode & 0xFF; //low byte\n    } else {\n      //ascii\n      newBuf[j++] = unicode;\n    }\n  }\n\n  return newBuf.slice(0, j);\n}\n\nfunction fromTableEncoding(buf) {\n  buf = ensureBuffer(buf);\n  var bufLen = buf.length;\n  var table = this.options.table;\n  var newBuf = new Buffer(bufLen * 2),\n      unicode,\n      gbkcode,\n      defaultChar = iconv.defaultCharUnicode.charCodeAt(0);\n\n  for (var i = 0, j = 0; i < bufLen; i++, j += 2) {\n    gbkcode = buf[i];\n\n    if (gbkcode & 0x80) {\n      gbkcode = (gbkcode << 8) + buf[++i];\n      unicode = table[gbkcode] || defaultChar;\n    } else {\n      unicode = gbkcode;\n    }\n\n    newBuf[j] = unicode & 0xFF; //low byte\n\n    newBuf[j + 1] = unicode >> 8; //high byte\n  }\n\n  return newBuf.slice(0, j).toString('ucs2');\n}\n\nfunction toSingleByteEncoding(str) {\n  str = ensureString(str);\n  var buf = new Buffer(str.length);\n  var revCharsBuf = this.options.revCharsBuf;\n\n  for (var i = 0; i < str.length; i++) buf[i] = revCharsBuf[str.charCodeAt(i)];\n\n  return buf;\n}\n\nfunction fromSingleByteEncoding(buf) {\n  buf = ensureBuffer(buf); // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n\n  var charsBuf = this.options.charsBuf;\n  var newBuf = new Buffer(buf.length * 2);\n  var idx1 = 0,\n      idx2 = 0;\n\n  for (var i = 0, _len = buf.length; i < _len; i++) {\n    idx1 = buf[i] * 2;\n    idx2 = i * 2;\n    newBuf[idx2] = charsBuf[idx1];\n    newBuf[idx2 + 1] = charsBuf[idx1 + 1];\n  }\n\n  return newBuf.toString('ucs2');\n} // Add aliases to convert functions\n\n\niconv.encode = iconv.toEncoding;\niconv.decode = iconv.fromEncoding; // Load other encodings manually from files in /encodings dir.\n\nfunction loadEncodings() {\n  if (!iconv.encodingsLoaded) {\n    [require('./encodings/singlebyte'), require('./encodings/gbk'), require('./encodings/big5')].forEach(function (encodings) {\n      for (var key in encodings) iconv.encodings[key] = encodings[key];\n    });\n    iconv.encodingsLoaded = true;\n  }\n} // Utilities\n\n\nvar asciiString = '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f' + ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f';\n\nvar ensureBuffer = function (buf) {\n  buf = buf || new Buffer(0);\n  return buf instanceof Buffer ? buf : new Buffer(\"\" + buf, \"binary\");\n};\n\nvar ensureString = function (str) {\n  str = str || \"\";\n  return str instanceof Buffer ? str.toString('utf8') : \"\" + str;\n};\n\nvar getType = function (obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1);\n};","map":null,"metadata":{},"sourceType":"script"}