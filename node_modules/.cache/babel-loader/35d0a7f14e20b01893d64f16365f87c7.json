{"ast":null,"code":"// YAML - Core - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Version triplet.\n */\nexports.version = '0.2.3'; // --- Helpers\n\n/**\n * Return 'near \"context\"' where context\n * is replaced by a chunk of _str_.\n *\n * @param  {string} str\n * @return {string}\n * @api public\n */\n\nfunction context(str) {\n  if (typeof str !== 'string') return '';\n  str = str.slice(0, 25).replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\\\"');\n  return 'near \"' + str + '\"';\n} // --- Lexer\n\n/**\n * YAML grammar tokens.\n */\n\n\nvar tokens = [['comment', /^#[^\\n]*/], ['indent', /^\\n( *)/], ['space', /^ +/], ['true', /^\\b(enabled|true|yes|on)\\b/], ['false', /^\\b(disabled|false|no|off)\\b/], ['null', /^\\b(null|Null|NULL|~)\\b/], ['string', /^\"(.*?)\"/], ['string', /^'(.*?)'/], ['timestamp', /^((\\d{4})-(\\d\\d?)-(\\d\\d?)(?:(?:[ \\t]+)(\\d\\d?):(\\d\\d)(?::(\\d\\d))?)?)/], ['float', /^(\\d+\\.\\d+)/], ['int', /^(\\d+)/], ['doc', /^---/], [',', /^,/], ['{', /^\\{(?![^\\n\\}]*\\}[^\\n]*[^\\s\\n\\}])/], ['}', /^\\}/], ['[', /^\\[(?![^\\n\\]]*\\][^\\n]*[^\\s\\n\\]])/], [']', /^\\]/], ['-', /^\\-/], [':', /^[:]/], ['string', /^(?![^:\\n\\s]*:[^\\/]{2})(([^:,\\]\\}\\n\\s]|(?!\\n)\\s(?!\\s*?\\n)|:\\/\\/|,(?=[^\\n]*\\s*[^\\]\\}\\s\\n]\\s*\\n)|[\\]\\}](?=[^\\n]*\\s*[^\\]\\}\\s\\n]\\s*\\n))*)(?=[,:\\]\\}\\s\\n]|$)/], ['id', /^([\\w][\\w -]*)/]];\n/**\n * Tokenize the given _str_.\n *\n * @param  {string} str\n * @return {array}\n * @api private\n */\n\nexports.tokenize = function (str) {\n  var token,\n      captures,\n      ignore,\n      input,\n      indents = 0,\n      lastIndents = 0,\n      stack = [],\n      indentAmount = -1;\n\n  while (str.length) {\n    for (var i = 0, len = tokens.length; i < len; ++i) if (captures = tokens[i][1].exec(str)) {\n      token = [tokens[i][0], captures], str = str.replace(tokens[i][1], '');\n\n      switch (token[0]) {\n        case 'comment':\n          ignore = true;\n          break;\n\n        case 'indent':\n          lastIndents = indents; // determine the indentation amount from the first indent\n\n          if (indentAmount == -1) {\n            indentAmount = token[1][1].length;\n          }\n\n          indents = token[1][1].length / indentAmount;\n          if (indents === lastIndents) ignore = true;else if (indents > lastIndents + 1) throw new SyntaxError('invalid indentation, got ' + indents + ' instead of ' + (lastIndents + 1));else if (indents < lastIndents) {\n            input = token[1].input;\n            token = ['dedent'];\n            token.input = input;\n\n            while (--lastIndents > indents) stack.push(token);\n          }\n      }\n\n      break;\n    }\n\n    if (!ignore) if (token) stack.push(token), token = null;else throw new SyntaxError(context(str));\n    ignore = false;\n  }\n\n  return stack;\n}; // --- Parser\n\n/**\n * Initialize with _tokens_.\n */\n\n\nfunction Parser(tokens) {\n  this.tokens = tokens;\n}\n/**\n * Look-ahead a single token.\n *\n * @return {array}\n * @api public\n */\n\n\nParser.prototype.peek = function () {\n  return this.tokens[0];\n};\n/**\n * Advance by a single token.\n *\n * @return {array}\n * @api public\n */\n\n\nParser.prototype.advance = function () {\n  return this.tokens.shift();\n};\n/**\n * Advance and return the token's value.\n *\n * @return {mixed}\n * @api private\n */\n\n\nParser.prototype.advanceValue = function () {\n  return this.advance()[1][1];\n};\n/**\n * Accept _type_ and advance or do nothing.\n *\n * @param  {string} type\n * @return {bool}\n * @api private\n */\n\n\nParser.prototype.accept = function (type) {\n  if (this.peekType(type)) return this.advance();\n};\n/**\n * Expect _type_ or throw an error _msg_.\n *\n * @param  {string} type\n * @param  {string} msg\n * @api private\n */\n\n\nParser.prototype.expect = function (type, msg) {\n  if (this.accept(type)) return;\n  throw new Error(msg + ', ' + context(this.peek()[1].input));\n};\n/**\n * Return the next token type.\n *\n * @return {string}\n * @api private\n */\n\n\nParser.prototype.peekType = function (val) {\n  return this.tokens[0] && this.tokens[0][0] === val;\n};\n/**\n * space*\n */\n\n\nParser.prototype.ignoreSpace = function () {\n  while (this.peekType('space')) this.advance();\n};\n/**\n * (space | indent | dedent)*\n */\n\n\nParser.prototype.ignoreWhitespace = function () {\n  while (this.peekType('space') || this.peekType('indent') || this.peekType('dedent')) this.advance();\n};\n/**\n *   block\n * | doc\n * | list\n * | inlineList\n * | hash\n * | inlineHash\n * | string\n * | float\n * | int\n * | true\n * | false\n * | null\n */\n\n\nParser.prototype.parse = function () {\n  switch (this.peek()[0]) {\n    case 'doc':\n      return this.parseDoc();\n\n    case '-':\n      return this.parseList();\n\n    case '{':\n      return this.parseInlineHash();\n\n    case '[':\n      return this.parseInlineList();\n\n    case 'id':\n      return this.parseHash();\n\n    case 'string':\n      return this.advanceValue();\n\n    case 'timestamp':\n      return this.parseTimestamp();\n\n    case 'float':\n      return parseFloat(this.advanceValue());\n\n    case 'int':\n      return parseInt(this.advanceValue());\n\n    case 'true':\n      this.advanceValue();\n      return true;\n\n    case 'false':\n      this.advanceValue();\n      return false;\n\n    case 'null':\n      this.advanceValue();\n      return null;\n  }\n};\n/**\n * '---'? indent expr dedent\n */\n\n\nParser.prototype.parseDoc = function () {\n  this.accept('doc');\n  this.expect('indent', 'expected indent after document');\n  var val = this.parse();\n  this.expect('dedent', 'document not properly dedented');\n  return val;\n};\n/**\n *  ( id ':' - expr -\n *  | id ':' - indent expr dedent\n *  )+\n */\n\n\nParser.prototype.parseHash = function () {\n  var id,\n      hash = {};\n\n  while (this.peekType('id') && (id = this.advanceValue())) {\n    this.expect(':', 'expected semi-colon after id');\n    this.ignoreSpace();\n    if (this.accept('indent')) hash[id] = this.parse(), this.expect('dedent', 'hash not properly dedented');else hash[id] = this.parse();\n    this.ignoreSpace();\n  }\n\n  return hash;\n};\n/**\n * '{' (- ','? ws id ':' - expr ws)* '}'\n */\n\n\nParser.prototype.parseInlineHash = function () {\n  var hash = {},\n      id,\n      i = 0;\n  this.accept('{');\n\n  while (!this.accept('}')) {\n    this.ignoreSpace();\n    if (i) this.expect(',', 'expected comma');\n    this.ignoreWhitespace();\n\n    if (this.peekType('id') && (id = this.advanceValue())) {\n      this.expect(':', 'expected semi-colon after id');\n      this.ignoreSpace();\n      hash[id] = this.parse();\n      this.ignoreWhitespace();\n    }\n\n    ++i;\n  }\n\n  return hash;\n};\n/**\n *  ( '-' - expr -\n *  | '-' - indent expr dedent\n *  )+\n */\n\n\nParser.prototype.parseList = function () {\n  var list = [];\n\n  while (this.accept('-')) {\n    this.ignoreSpace();\n    if (this.accept('indent')) list.push(this.parse()), this.expect('dedent', 'list item not properly dedented');else list.push(this.parse());\n    this.ignoreSpace();\n  }\n\n  return list;\n};\n/**\n * '[' (- ','? - expr -)* ']'\n */\n\n\nParser.prototype.parseInlineList = function () {\n  var list = [],\n      i = 0;\n  this.accept('[');\n\n  while (!this.accept(']')) {\n    this.ignoreSpace();\n    if (i) this.expect(',', 'expected comma');\n    this.ignoreSpace();\n    list.push(this.parse());\n    this.ignoreSpace();\n    ++i;\n  }\n\n  return list;\n};\n/**\n * yyyy-mm-dd hh:mm:ss\n *\n * For full format: http://yaml.org/type/timestamp.html\n */\n\n\nParser.prototype.parseTimestamp = function () {\n  var token = this.advance()[1];\n  var date = new Date();\n  var year = token[2],\n      month = token[3],\n      day = token[4],\n      hour = token[5] || 0,\n      min = token[6] || 0,\n      sec = token[7] || 0;\n  date.setUTCFullYear(year, month - 1, day);\n  date.setUTCHours(hour);\n  date.setUTCMinutes(min);\n  date.setUTCSeconds(sec);\n  date.setUTCMilliseconds(0);\n  return date;\n};\n/**\n * Evaluate a _str_ of yaml.\n *\n * @param  {string} str\n * @return {mixed}\n * @api public\n */\n\n\nexports.eval = function (str) {\n  return new Parser(exports.tokenize(str)).parse();\n};","map":null,"metadata":{},"sourceType":"script"}