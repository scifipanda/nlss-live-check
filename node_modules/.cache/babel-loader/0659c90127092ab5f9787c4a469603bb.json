{"ast":null,"code":"var util = require('util'),\n    events = require(\"events\"),\n    http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    qs = require('qs'),\n    multipart = require('./multipartform'),\n    zlib = require('zlib'),\n    iconv = require('iconv-lite');\n\nfunction mixin(target, source) {\n  source = source || {};\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n\nfunction Request(uri, options) {\n  events.EventEmitter.call(this);\n  this.url = url.parse(uri);\n  this.options = options;\n  this.headers = {\n    'Accept': '*/*',\n    'User-Agent': 'Restler for node.js',\n    'Host': this.url.host\n  };\n  this.headers['Accept-Encoding'] = 'gzip, deflate';\n  mixin(this.headers, options.headers || {}); // set port and method defaults\n\n  if (!this.url.port) this.url.port = this.url.protocol == 'https:' ? '443' : '80';\n  if (!this.options.method) this.options.method = this.options.data ? 'POST' : 'GET';\n  if (typeof this.options.followRedirects == 'undefined') this.options.followRedirects = true; // stringify query given in options of not given in URL\n\n  if (this.options.query && !this.url.query) {\n    if (typeof this.options.query == 'object') this.url.query = qs.stringify(this.options.query);else this.url.query = this.options.query;\n  }\n\n  this._applyAuth();\n\n  if (this.options.multipart) {\n    this.headers['Content-Type'] = 'multipart/form-data; boundary=' + multipart.defaultBoundary;\n    var multipart_size = multipart.sizeOf(this.options.data, multipart.defaultBoundary);\n\n    if (typeof multipart_size === 'number' && multipart_size === multipart_size) {\n      this.headers['Content-Length'] = multipart_size;\n    } else {\n      console.log(\"Building multipart request without Content-Length header, please specify all file sizes\");\n    }\n  } else {\n    if (typeof this.options.data == 'object' && !Buffer.isBuffer(this.options.data)) {\n      this.options.data = qs.stringify(this.options.data);\n      this.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      this.headers['Content-Length'] = this.options.data.length;\n    }\n\n    if (typeof this.options.data == 'string') {\n      var buffer = new Buffer(this.options.data, this.options.encoding || 'utf8');\n      this.options.data = buffer;\n      this.headers['Content-Length'] = buffer.length;\n    }\n\n    if (!this.options.data) {\n      this.headers['Content-Length'] = 0;\n    }\n  }\n\n  var proto = this.url.protocol == 'https:' ? https : http;\n  this.request = proto.request({\n    host: this.url.hostname,\n    port: this.url.port,\n    path: this._fullPath(),\n    method: this.options.method,\n    headers: this.headers,\n    rejectUnauthorized: this.options.rejectUnauthorized,\n    agent: this.options.agent\n  });\n\n  this._makeRequest();\n}\n\nutil.inherits(Request, events.EventEmitter);\nmixin(Request.prototype, {\n  _isRedirect: function (response) {\n    return [301, 302, 303, 307].indexOf(response.statusCode) >= 0;\n  },\n  _fullPath: function () {\n    var path = this.url.pathname || '/';\n    if (this.url.hash) path += this.url.hash;\n    if (this.url.query) path += '?' + this.url.query;\n    return path;\n  },\n  _applyAuth: function () {\n    var authParts;\n\n    if (this.url.auth) {\n      authParts = this.url.auth.split(':');\n      this.options.username = authParts[0];\n      this.options.password = authParts[1];\n    }\n\n    if (this.options.username && this.options.password !== undefined) {\n      var b = new Buffer([this.options.username, this.options.password].join(':'));\n      this.headers['Authorization'] = \"Basic \" + b.toString('base64');\n    } else if (this.options.accessToken) {\n      this.headers['Authorization'] = \"Bearer \" + this.options.accessToken;\n    }\n  },\n  _responseHandler: function (response) {\n    var self = this;\n\n    if (self._isRedirect(response) && self.options.followRedirects) {\n      try {\n        // 303 should redirect and retrieve content with the GET method\n        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n        if (response.statusCode === 303) {\n          self.url = url.parse(url.resolve(self.url.href, response.headers['location']));\n          self.options.method = 'GET';\n          delete self.options.data;\n\n          self._retry();\n        } else {\n          self.url = url.parse(url.resolve(self.url.href, response.headers['location']));\n\n          self._retry(); // todo handle somehow infinite redirects\n\n        }\n      } catch (err) {\n        err.message = 'Failed to follow redirect: ' + err.message;\n\n        self._fireError(err, response);\n      }\n    } else {\n      var body = ''; // When using browserify, response.setEncoding is not defined\n\n      if (typeof response.setEncoding == 'function') response.setEncoding('binary');\n      response.on('data', function (chunk) {\n        body += chunk;\n      });\n      response.on('end', function () {\n        response.rawEncoded = body;\n\n        self._decode(new Buffer(body, 'binary'), response, function (err, body) {\n          if (err) {\n            self._fireError(err, response);\n\n            return;\n          }\n\n          response.raw = body;\n          body = self._iconv(body, response);\n\n          self._encode(body, response, function (err, body) {\n            if (err) {\n              self._fireError(err, response);\n            } else {\n              self._fireSuccess(body, response);\n            }\n          });\n        });\n      });\n    }\n  },\n  _decode: function (body, response, callback) {\n    var decoder = response.headers['content-encoding'];\n\n    if (decoder in decoders) {\n      decoders[decoder].call(response, body, callback);\n    } else {\n      callback(null, body);\n    }\n  },\n  _iconv: function (body, response) {\n    var charset = response.headers['content-type'];\n\n    if (charset) {\n      charset = /\\bcharset=(.+)(?:;|$)/i.exec(charset);\n\n      if (charset) {\n        charset = charset[1].trim().toUpperCase();\n\n        if (charset != 'UTF-8') {\n          try {\n            return iconv.decode(body, charset);\n          } catch (err) {}\n        }\n      }\n    }\n\n    return body;\n  },\n  _encode: function (body, response, callback) {\n    var self = this;\n\n    if (self.options.decoding == 'buffer') {\n      callback(null, body);\n    } else {\n      body = body.toString(self.options.decoding);\n\n      if (self.options.parser) {\n        self.options.parser.call(response, body, callback);\n      } else {\n        callback(null, body);\n      }\n    }\n  },\n  _fireError: function (err, response) {\n    this._fireCancelTimeout();\n\n    this.emit('error', err, response);\n    this.emit('complete', err, response);\n  },\n  _fireCancelTimeout: function () {\n    var self = this;\n\n    if (self.options.timeout) {\n      clearTimeout(self.options.timeoutFn);\n    }\n  },\n  _fireTimeout: function (err) {\n    this.emit('timeout', err);\n    this.aborted = true;\n    this.timedout = true;\n    this.request.abort();\n  },\n  _fireSuccess: function (body, response) {\n    if (parseInt(response.statusCode) >= 400) {\n      this.emit('fail', body, response);\n    } else {\n      this.emit('success', body, response);\n    }\n\n    this.emit(response.statusCode.toString().replace(/\\d{2}$/, 'XX'), body, response);\n    this.emit(response.statusCode.toString(), body, response);\n    this.emit('complete', body, response);\n  },\n  _makeRequest: function () {\n    var self = this;\n    var timeoutMs = self.options.timeout;\n\n    if (timeoutMs) {\n      self.options.timeoutFn = setTimeout(function () {\n        self._fireTimeout(timeoutMs);\n      }, timeoutMs);\n    }\n\n    this.request.on('response', function (response) {\n      self._fireCancelTimeout();\n\n      self.emit('response', response);\n\n      self._responseHandler(response);\n    }).on('error', function (err) {\n      self._fireCancelTimeout();\n\n      if (!self.aborted) {\n        self._fireError(err, null);\n      }\n    });\n  },\n  _retry: function () {\n    this.request.removeAllListeners().on('error', function () {});\n\n    if (this.request.finished) {\n      this.request.abort();\n    }\n\n    Request.call(this, this.url.href, this.options); // reusing request object to handle recursive calls and remember listeners\n\n    this.run();\n  },\n  run: function () {\n    var self = this;\n\n    if (this.options.multipart) {\n      multipart.write(this.request, this.options.data, function () {\n        self.request.end();\n      });\n    } else {\n      if (this.options.data) {\n        this.request.write(this.options.data, this.options.encoding || 'utf8');\n      }\n\n      this.request.end();\n    }\n\n    return this;\n  },\n  abort: function (err) {\n    var self = this;\n\n    if (err) {\n      if (typeof err == 'string') {\n        err = new Error(err);\n      } else if (!(err instanceof Error)) {\n        err = new Error('AbortError');\n      }\n\n      err.type = 'abort';\n    } else {\n      err = null;\n    }\n\n    self.request.on('close', function () {\n      if (err) {\n        self._fireError(err, null);\n      } else {\n        self.emit('complete', null, null);\n      }\n    });\n    self.aborted = true;\n    self.request.abort();\n    self.emit('abort', err);\n    return this;\n  },\n  retry: function (timeout) {\n    var self = this;\n    timeout = parseInt(timeout);\n\n    var fn = self._retry.bind(self);\n\n    if (!isFinite(timeout) || timeout <= 0) {\n      process.nextTick(fn, timeout);\n    } else {\n      setTimeout(fn, timeout);\n    }\n\n    return this;\n  }\n});\n\nfunction shortcutOptions(options, method) {\n  options = options || {};\n  options.method = method;\n  options.parser = typeof options.parser !== \"undefined\" ? options.parser : parsers.auto;\n  parsers.xml.options = typeof options.xml2js == 'undefined' ? {} : options.xml2js;\n  return options;\n}\n\nfunction request(url, options) {\n  var request = new Request(url, options);\n  request.on('error', function () {});\n  process.nextTick(request.run.bind(request));\n  return request;\n}\n\nfunction get(url, options) {\n  return request(url, shortcutOptions(options, 'GET'));\n}\n\nfunction patch(url, options) {\n  return request(url, shortcutOptions(options, 'PATCH'));\n}\n\nfunction post(url, options) {\n  return request(url, shortcutOptions(options, 'POST'));\n}\n\nfunction put(url, options) {\n  return request(url, shortcutOptions(options, 'PUT'));\n}\n\nfunction del(url, options) {\n  return request(url, shortcutOptions(options, 'DELETE'));\n}\n\nfunction head(url, options) {\n  return request(url, shortcutOptions(options, 'HEAD'));\n}\n\nfunction json(url, data, options, method) {\n  options = options || {};\n  options.parser = typeof options.parser !== \"undefined\" ? options.parser : parsers.auto;\n  options.headers = options.headers || {};\n  options.headers['content-type'] = 'application/json';\n  options.data = JSON.stringify(data || {});\n  options.method = method || 'GET';\n  return request(url, options);\n}\n\nfunction postJson(url, data, options) {\n  return json(url, data, options, 'POST');\n}\n\nfunction putJson(url, data, options) {\n  return json(url, data, options, 'PUT');\n}\n\nfunction patchJson(url, data, options) {\n  return json(url, data, options, 'PATCH');\n}\n\nvar parsers = {\n  auto: function (data, callback) {\n    var contentType = this.headers['content-type'];\n    var contentParser;\n\n    if (contentType) {\n      contentType = contentType.replace(/;.+/, ''); // remove all except mime type (eg. text/html; charset=UTF-8)\n\n      if (contentType in parsers.auto.matchers) {\n        contentParser = parsers.auto.matchers[contentType];\n      } else {\n        // custom (vendor) mime types\n        var parts = contentType.match(/^([\\w-]+)\\/vnd((?:\\.(?:[\\w-]+))+)\\+([\\w-]+)$/i);\n\n        if (parts) {\n          var type = parts[1];\n          var vendors = parts[2].substr(1).split('.');\n          var subtype = parts[3];\n          var vendorType;\n\n          while (vendors.pop() && !(vendorType in parsers.auto.matchers)) {\n            vendorType = vendors.length ? type + '/vnd.' + vendors.join('.') + '+' + subtype : vendorType = type + '/' + subtype;\n          }\n\n          contentParser = parsers.auto.matchers[vendorType];\n        }\n      }\n    }\n\n    if (typeof contentParser == 'function') {\n      contentParser.call(this, data, callback);\n    } else {\n      callback(null, data);\n    }\n  },\n  json: function (data, callback) {\n    if (data && data.length) {\n      var parsedData;\n\n      try {\n        parsedData = JSON.parse(data);\n      } catch (err) {\n        err.message = 'Failed to parse JSON body: ' + err.message;\n        callback(err, null);\n      }\n\n      if (parsedData !== undefined) {\n        callback(null, parsedData);\n      }\n    } else {\n      callback(null, null);\n    }\n  }\n};\nparsers.auto.matchers = {\n  'application/json': parsers.json\n};\n\ntry {\n  var yaml = require('yaml');\n\n  parsers.yaml = function (data, callback) {\n    if (data) {\n      try {\n        callback(null, yaml.eval(data));\n      } catch (err) {\n        err.message = 'Failed to parse YAML body: ' + err.message;\n        callback(err, null);\n      }\n    } else {\n      callback(null, null);\n    }\n  };\n\n  parsers.auto.matchers['application/yaml'] = parsers.yaml;\n} catch (e) {}\n\ntry {\n  var xml2js = require('xml2js');\n\n  parsers.xml = function (data, callback) {\n    if (data) {\n      var parser = new xml2js.Parser(parsers.xml.options);\n      parser.parseString(data, function (err, data) {\n        if (err) {\n          err.message = 'Failed to parse XML body: ' + err.message;\n        }\n\n        callback(err, data);\n      });\n    } else {\n      callback(null, null);\n    }\n  };\n\n  parsers.auto.matchers['application/xml'] = parsers.xml;\n} catch (e) {}\n\nvar decoders = {\n  gzip: function (buf, callback) {\n    zlib.gunzip(buf, callback);\n  },\n  deflate: function (buf, callback) {\n    zlib.inflate(buf, callback);\n  }\n};\n\nfunction Service(defaults) {\n  if (defaults.baseURL) {\n    this.baseURL = defaults.baseURL;\n    delete defaults.baseURL;\n  }\n\n  this.defaults = defaults;\n}\n\nmixin(Service.prototype, {\n  request: function (path, options) {\n    return request(this._url(path), this._withDefaults(options));\n  },\n  get: function (path, options) {\n    return get(this._url(path), this._withDefaults(options));\n  },\n  patch: function (path, options) {\n    return patch(this._url(path), this._withDefaults(options));\n  },\n  put: function (path, options) {\n    return put(this._url(path), this._withDefaults(options));\n  },\n  post: function (path, options) {\n    return post(this._url(path), this._withDefaults(options));\n  },\n  json: function (method, path, data, options) {\n    return json(this._url(path), data, this._withDefaults(options), method);\n  },\n  del: function (path, options) {\n    return del(this._url(path), this._withDefaults(options));\n  },\n  _url: function (path) {\n    if (this.baseURL) return url.resolve(this.baseURL, path);else return path;\n  },\n  _withDefaults: function (options) {\n    var o = mixin({}, this.defaults);\n    return mixin(o, options);\n  }\n});\n\nfunction service(constructor, defaults, methods) {\n  constructor.prototype = new Service(defaults || {});\n  mixin(constructor.prototype, methods);\n  return constructor;\n}\n\nmixin(exports, {\n  Request: Request,\n  Service: Service,\n  request: request,\n  service: service,\n  get: get,\n  patch: patch,\n  post: post,\n  put: put,\n  del: del,\n  head: head,\n  json: json,\n  postJson: postJson,\n  putJson: putJson,\n  patchJson: patchJson,\n  parsers: parsers,\n  file: multipart.file,\n  data: multipart.data\n});","map":null,"metadata":{},"sourceType":"script"}